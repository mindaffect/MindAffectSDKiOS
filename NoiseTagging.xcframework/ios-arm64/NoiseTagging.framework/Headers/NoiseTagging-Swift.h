// Generated by Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import AVFoundation;
@import CoreGraphics;
@import Foundation;
@import ObjectiveC;
@import QuartzCore;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="NoiseTagging",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class ResultValidityCheck;
@protocol SettingObserver;

/// Objects conforming to this protocol can be used as <em>Settings</em>. This a.o. means they have a value that can be set and get, and that the NoiseTagging framework can provide the user with UI to edit the setting.
/// The easiest way to conform to <code>Setting</code> is to subclass <code>Setting_abstract</code>.
/// seealso:
/// Settings can be grouped together in a <code>SetOfSettings</code>.
SWIFT_PROTOCOL("_TtP12NoiseTagging7Setting_")
@protocol Setting <NSCopying, NSObject>
/// The setting’s title, as displayed in the UI.
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
/// Whether the settings is editable by the user.
@property (nonatomic) BOOL isEditable;
/// Whether the setting allows to be undefined.
/// important:
/// we do not use optionals for representing specific setting type values. Instead in most cases the concept of ‘undefined’ is irrelevant. This property, as well as <code>allowsUndefined</code>, is only used for implementing the ‘Feedback Screen’, where ‘undefined’ should be the default for all ‘settings’. But these ‘settings’ are only used for logging purposes.
@property (nonatomic) BOOL allowsUndefined;
/// If the setting is part of a <code>SetOfSettings</code> and UI is displayed to edit that set, this determines whether the setting is also visible in the UI.
@property (nonatomic) BOOL isVisibleInUI;
/// An explanation for the user about what the setting  exactly is about.
@property (nonatomic, copy) NSString * _Nullable help;
/// A closure which checks whether a certain value is a valid value for the setting.
/// This closure gets a ‘candidate’ for the setting’s new value and should return nil if that candidate is ‘valid’. If it is not valid, the closure should return an explanation for the user why the value is not valid.
/// attention:
/// Classes that implement the <code>Setting</code> protocol should perform the <code>validityCheck</code> before they actually change their setting value. They should also not forget to copy the <code>validityCheck</code> in their copy function.
@property (nonatomic, copy) ResultValidityCheck * _Nonnull (^ _Nullable validityCheck)(id _Nonnull);
/// Settings always have a default value, which is their initial value. This default value can easily be restored by the user using the standard UI for editing settings provided by the NoiseTagging framework.
@property (nonatomic, readonly) BOOL valueEqualsDefaultValue;
/// Whether the setting’s value is ‘undefined’. Only relevant if <code>allowsUndefined</code> is <code>true</code>.
/// seealso:
/// <code>allowsUndefined</code>.
@property (nonatomic) BOOL valueIsUndefined;
/// Sets the receiver’s setting value to the setting value of <code>newSetting</code>.
- (void)updateValueToMatchWithNewSetting:(id <Setting> _Nonnull)newSetting;
/// Set the setting value to the default value.
/// seealso:
/// <code>hasDefaultValue</code>
- (void)resetToDefault;
/// Set the setting value to <code>undefined</code>.
/// seealso:
/// <code>allowsUndefined</code>.
- (void)setToUndefined;
/// An optional closures that is executed just before changing the setting’s value:
@property (nonatomic, copy) void (^ _Nullable actionBeforeChange)(void);
/// An optional closures that is executed just after changing the setting’s value:
@property (nonatomic, copy) void (^ _Nullable actionAfterChange)(void);
/// A setting’s observers are informed whenever the setting’s value changes.
@property (nonatomic, copy) NSArray<id <SettingObserver>> * _Nonnull observers;
/// Add a new observer, which is informed whenever the setting’s value changes.
- (void)addWithObserver:(id <SettingObserver> _Nonnull)observer;
/// Remove an observer, so it is no longer informed whenever the setting’s value changes.
- (void)removeWithObserver:(id <SettingObserver> _Nonnull)observer;
@optional
/// The setting’s value described using JSON. Used for logging purposes.
@property (nonatomic, readonly) id _Nonnull valueAsJson;
@required
/// A description of the setting’s value, assuming a value is defined. Used for logging purposes.
@property (nonatomic, readonly, copy) NSString * _Nonnull descriptionValueIfDefined;
/// A description of the setting’s value, be it defined or undefined. Used for logging purposes.
@property (nonatomic, readonly, copy) NSString * _Nonnull descriptionValue;
/// The name of the nib used for generating UI for editing the setting.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellNibName;
/// The NoiseTagging framework provides standard UI for editing settings. This UI consists of a table view, where each cell is used for one setting. The <code>cellReuseIdentifier</code> makes it possible to reuse these cells per setting type.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellReuseIdentifier;
@end


/// Setting classes can subclass this abstract class to more easily implement the <code>Setting</code> protocol.
/// important:
/// subclasses should call <code>valueWillChange</code> and <code>valueChanged</code> at appropriate times.
SWIFT_CLASS("_TtC12NoiseTagging16Setting_abstract")
@interface Setting_abstract : NSObject
/// The setting’s title, as displayed in the UI.
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
/// Whether the settings is editable by the user.
/// Settings are editable by default.
@property (nonatomic) BOOL isEditable;
/// Whether the setting allows to be undefined.
/// Settings cannot be undefined by default.
/// important:
/// we do not use optionals for representing specific setting type values. Instead in most cases the concept of ‘undefined’ is irrelevant. This property, as well as <code>allowsUndefined</code>, is only used for implementing the ‘Feedback Screen’, where ‘undefined’ should be the default for all ‘settings’. But these ‘settings’ are only used for logging purposes.
@property (nonatomic) BOOL allowsUndefined;
/// If the setting is part of a <code>SetOfSettings</code> and UI is displayed to edit that set, this determines whether the setting is also visible in the UI.
/// Settings are visible by default.
@property (nonatomic) BOOL isVisibleInUI;
/// An explanation for the user about what the setting exactly is about.
@property (nonatomic, copy) NSString * _Nullable help;
/// A closure which checks whether a certain value is a valid value for the setting.
/// This closure gets a ‘candidate’ for the setting’s new value and should return nil if that candidate is ‘valid’. If it is not valid, the closure should return an explanation for the user why the value is not valid.
/// attention:
/// Classes that implement the <code>Setting</code> protocol should perform the <code>validityCheck</code> before they actually change their setting value. They should also not forget to copy the <code>validityCheck</code> in their copy function.
@property (nonatomic, copy) ResultValidityCheck * _Nonnull (^ _Nullable validityCheck)(id _Nonnull);
/// Whether the setting is ‘undefined’. Only relevant if <code>allowsUndefined</code> is <code>true</code>.
/// seealso:
/// <code>allowsUndefined</code>.
@property (nonatomic) BOOL valueIsUndefined;
/// Set the setting value to <code>undefined</code>.
/// By default this means setting <code>allowsUndefined</code> and <code>isUndefined</code> to <code>true</code>.
/// seealso:
/// <code>allowsUndefined</code>.
- (void)setToUndefined;
/// An optional closures that is executed just before changing the setting’s value:
@property (nonatomic, copy) void (^ _Nullable actionBeforeChange)(void);
/// An optional closures that is executed just after changing the setting’s value:
@property (nonatomic, copy) void (^ _Nullable actionAfterChange)(void);
/// A setting’s observers are informed whenever the setting’s value changes.
@property (nonatomic, copy) NSArray<id <SettingObserver>> * _Nonnull observers;
/// Add a new observer, which is informed whenever the setting’s value changes.
- (void)addWithObserver:(id <SettingObserver> _Nonnull)observer;
/// Remove an observer, so it is no longer informed whenever the setting’s value changes.
- (void)removeWithObserver:(id <SettingObserver> _Nonnull)observer;
/// Subclasses should NOT override <code>descriptionValue</code>. Instead they should implement <code>descriptionValueIfDefined</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull descriptionValue;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSCoder;

/// A <code>Setting</code> with a <code>Bool</code> value.
SWIFT_CLASS("_TtC12NoiseTagging11BoolSetting")
@interface BoolSetting : Setting_abstract <NSCoding, Setting>
/// Copy the <code>BoolSetting</code>.
/// seealso:
/// <code>NSCopying</code>.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// Encode the <code>BoolSetting</code>.
/// seealso:
/// <code>NSCoding</code>.
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// Initialize a new <code>BoolSetting</code> by decoding from <code>aDecoder</code>.
/// seealso:
/// <code>NSCoding</code>.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// A user-friendly description of the <code>BoolSetting</code>.
/// seealso:
/// <code>CustomStringConvertible</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// A description of the setting’s value, assuming a value is defined. Used for logging purposes.
@property (nonatomic, readonly, copy) NSString * _Nonnull descriptionValueIfDefined;
/// The setting’s value described using JSON. Used for logging purposes.
@property (nonatomic, readonly) id _Nonnull valueAsJson;
/// Sets the receiver’s setting value to the setting value of <code>newSetting</code>.
- (void)updateValueToMatchWithNewSetting:(id <Setting> _Nonnull)newSetting;
/// Settings may have a default value, which can easily be restored by the user using the standard UI for editing settings provided by the NoiseTagging framework.
@property (nonatomic, readonly) BOOL valueEqualsDefaultValue;
/// Set the setting value to the default value.
/// seealso:
/// <code>hasDefaultValue</code>
- (void)resetToDefault;
/// The name of the nib used for generating UI for editing the setting.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellNibName;
/// The NoiseTagging framework provides standard UI for editing settings. This UI consists of a table view, where each cell is used for one setting. The <code>cellReuseIdentifier</code> makes it possible to reuse these cells per setting type.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellReuseIdentifier;
@end




/// A <code>Setting</code> with a color value.
/// The color is defined by one of two options:
/// <ol>
///   <li>
///     It is one of the ‘pickable colors’, which are predefined colors (<code>PickableColor</code>) as set on <code>var pickableColors</code>.
///   </li>
///   <li>
///     It is specified using RGBA.
///   </li>
/// </ol>
SWIFT_CLASS("_TtC12NoiseTagging12ColorSetting")
@interface ColorSetting : Setting_abstract <Setting>
/// Copy the <code>ColorSetting</code>.
/// seealso:
/// <code>NSCopying</code>.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// A user-friendly description of the <code>ColorSetting</code>.
/// seealso:
/// <code>CustomStringConvertible</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// A description of the setting’s value, assuming a value is defined. Used for logging purposes.
@property (nonatomic, readonly, copy) NSString * _Nonnull descriptionValueIfDefined;
/// Sets the receiver’s setting value to the setting value of <code>newSetting</code>.
- (void)updateValueToMatchWithNewSetting:(id <Setting> _Nonnull)newSetting;
/// Settings may have a default value, which can easily be restored by the user using the standard UI for editing settings provided by the NoiseTagging framework.
@property (nonatomic, readonly) BOOL valueEqualsDefaultValue;
/// Set the setting value to the default value.
/// seealso:
/// <code>hasDefaultValue</code>
- (void)resetToDefault;
/// The name of the nib used for generating UI for editing the setting.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellNibName;
/// The NoiseTagging framework provides standard UI for editing settings. This UI consists of a table view, where each cell is used for one setting. The <code>cellReuseIdentifier</code> makes it possible to reuse these cells per setting type.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellReuseIdentifier;
@end


/// A <code>Setting</code> with a <code>Double</code> value.
SWIFT_CLASS("_TtC12NoiseTagging13DoubleSetting")
@interface DoubleSetting : Setting_abstract <NSCoding, Setting>
/// Copy the <code>DoubleSetting</code>.
/// seealso:
/// <code>NSCopying</code>.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// Encode the <code>DoubleSetting</code>.
/// seealso:
/// <code>NSCoding</code>.
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// Initialize a new <code>DoubleSetting</code> by decoding from <code>aDecoder</code>.
/// seealso:
/// <code>NSCoding</code>.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// A user-friendly description of the <code>DoubleSetting</code>.
/// seealso:
/// <code>CustomStringConvertible</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// A description of the setting’s value, assuming a value is defined. Used for logging purposes.
@property (nonatomic, readonly, copy) NSString * _Nonnull descriptionValueIfDefined;
/// The setting’s value described using JSON. Used for logging purposes.
@property (nonatomic, readonly) id _Nonnull valueAsJson;
/// Sets the receiver’s setting value to the setting value of <code>newSetting</code>.
- (void)updateValueToMatchWithNewSetting:(id <Setting> _Nonnull)newSetting;
/// Settings may have a default value, which can easily be restored by the user using the standard UI for editing settings provided by the NoiseTagging framework.
@property (nonatomic, readonly) BOOL valueEqualsDefaultValue;
/// Set the setting value to the default value.
/// seealso:
/// <code>hasDefaultValue</code>
- (void)resetToDefault;
/// The name of the nib used for generating UI for editing the setting.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellNibName;
/// The NoiseTagging framework provides standard UI for editing settings. This UI consists of a table view, where each cell is used for one setting. The <code>cellReuseIdentifier</code> makes it possible to reuse these cells per setting type.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellReuseIdentifier;
@end


/// A <code>Setting</code> with a <code>EnumAsSettingProtocol</code> value.
SWIFT_CLASS("_TtC12NoiseTagging11EnumSetting")
@interface EnumSetting : Setting_abstract <Setting>
/// Copy the <code>EnumSetting</code>.
/// seealso:
/// <code>NSCopying</code>.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// A user-friendly description of the <code>EnumSetting</code>.
/// seealso:
/// <code>CustomStringConvertible</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// A description of the setting’s value, assuming a value is defined. Used for logging purposes.
@property (nonatomic, readonly, copy) NSString * _Nonnull descriptionValueIfDefined;
/// Sets the receiver’s setting value to the setting value of <code>newSetting</code>.
- (void)updateValueToMatchWithNewSetting:(id <Setting> _Nonnull)newSetting;
/// Settings may have a default value, which can easily be restored by the user using the standard UI for editing settings provided by the NoiseTagging framework.
@property (nonatomic, readonly) BOOL valueEqualsDefaultValue;
/// Set the setting value to the default value.
/// seealso:
/// <code>hasDefaultValue</code>
- (void)resetToDefault;
/// The name of the nib used for generating UI for editing the setting.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellNibName;
/// The NoiseTagging framework provides standard UI for editing settings. This UI consists of a table view, where each cell is used for one setting. The <code>cellReuseIdentifier</code> makes it possible to reuse these cells per setting type.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellReuseIdentifier;
@end


/// The url and filename of a file that is part of a <code>Recording</code>.
SWIFT_CLASS("_TtC12NoiseTagging15FileOfRecording")
@interface FileOfRecording : NSObject <NSCoding>
/// See the <code>NSCoding</code> protocol.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// See the <code>NSCoding</code> protocol.
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A <code>Setting</code> with an <code>Int</code> value.
SWIFT_CLASS("_TtC12NoiseTagging10IntSetting")
@interface IntSetting : Setting_abstract <NSCoding, Setting>
/// Copy the <code>IntSetting</code>.
/// seealso:
/// <code>NSCopying</code>.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// Encode the <code>IntSetting</code>.
/// seealso:
/// <code>NSCoding</code>.
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// Initialize a new <code>IntSetting</code> by decoding from <code>aDecoder</code>.
/// seealso:
/// <code>NSCoding</code>.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// A user-friendly description of the <code>IntSetting</code>.
/// seealso:
/// <code>CustomStringConvertible</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// A description of the setting’s value, assuming a value is defined. Used for logging purposes.
@property (nonatomic, readonly, copy) NSString * _Nonnull descriptionValueIfDefined;
/// The setting’s value described using JSON. Used for logging purposes.
@property (nonatomic, readonly) id _Nonnull valueAsJson;
/// Sets the receiver’s setting value to the setting value of <code>newSetting</code>.
- (void)updateValueToMatchWithNewSetting:(id <Setting> _Nonnull)newSetting;
/// Settings may have a default value, which can easily be restored by the user using the standard UI for editing settings provided by the NoiseTagging framework.
@property (nonatomic, readonly) BOOL valueEqualsDefaultValue;
/// Set the setting value to the default value.
/// seealso:
/// <code>hasDefaultValue</code>
- (void)resetToDefault;
/// The name of the nib used for generating UI for editing the setting.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellNibName;
/// The NoiseTagging framework provides standard UI for editing settings. This UI consists of a table view, where each cell is used for one setting. The <code>cellReuseIdentifier</code> makes it possible to reuse these cells per setting type.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellReuseIdentifier;
@end


/// A <code>Setting</code> which models an array of possible values and one of those values being selected.
SWIFT_CLASS("_TtC12NoiseTagging18ItemOfArraySetting")
@interface ItemOfArraySetting : Setting_abstract <Setting>
/// Copy the <code>ItemOfArraySetting</code>.
/// seealso:
/// <code>NSCopying</code>.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// A user-friendly description of the <code>ItemOfArraySetting</code>.
/// seealso:
/// <code>CustomStringConvertible</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// A description of the setting’s value, assuming a value is defined. Used for logging purposes.
@property (nonatomic, readonly, copy) NSString * _Nonnull descriptionValueIfDefined;
/// Sets the receiver’s setting value to the setting value of <code>newSetting</code>.
- (void)updateValueToMatchWithNewSetting:(id <Setting> _Nonnull)newSetting;
/// Settings may have a default value, which can easily be restored by the user using the standard UI for editing settings provided by the NoiseTagging framework.
@property (nonatomic, readonly) BOOL valueEqualsDefaultValue;
/// Set the setting value to the default value.
/// seealso:
/// <code>hasDefaultValue</code>
- (void)resetToDefault;
/// The name of the nib used for generating UI for editing the setting.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellNibName;
/// The NoiseTagging framework provides standard UI for editing settings. This UI consists of a table view, where each cell is used for one setting. The <code>cellReuseIdentifier</code> makes it possible to reuse these cells per setting type.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellReuseIdentifier;
@end



@class UIView;
@class UIColor;
@protocol NoiseTagControl;

/// The main responsibility of a <code>NoiseTagDelegate</code> is to prepare a unit for brain control by assigning actions to controls.
SWIFT_PROTOCOL("_TtP12NoiseTagging16NoiseTagDelegate_")
@protocol NoiseTagDelegate
@optional
/// When a unit becomes the current unit – because it has been pushed, or because another unit was popped –, or if <code>NoiseTagging.update(view:forNoiseTaggingWithDelegate:)</code> is called, <code>NoiseTagging</code> calls this function on the delegate.
/// <ul>
///   <li>
///     Example:
///   </li>
/// </ul>
/// \code
/// func startNoiseTagControlOn(noiseTaggingView: UIView) {
///        // Add noise tagging actions:
///
///        // For some types of controls you add actions directly:
///        someNoiseTagButtonView.noiseTagging.addAction(timing: 0) {
///            // This code is executed when the button is pressed:
///            NoiseTagController.print("Hello")
///        }
///
///        // For some types of controls you add actions indirectly. E.g. a NoiseTagPopupButtonView's action always is the same and you only need to enable brain control on it:
///        someNoiseTagPopupButtonView.noiseTagControlIsOn = true
///    }
///
/// \endcode
- (void)startNoiseTagControlOnNoiseTaggingView:(UIView * _Nonnull)noiseTaggingView;
/// Optionally define an alternative background color for the view. By default the color is defined by <code>NoiseTagController</code>’s <code>defaultBackgroundColorPrimary</code> setting.
- (UIColor * _Nullable)customBackgroundColorForNoiseTaggingView:(UIView * _Nonnull)noiseTaggingView SWIFT_WARN_UNUSED_RESULT;
/// In some modes the framework randomly selects one of the controls as the <em>target</em>. By implementing this function, the delegate can limit the set of controls that can be selected as the target.
- (NSArray<NSString *> * _Nullable)idsOfControlsToIncludeAsTargetInVerifyModeWithNoiseTaggingView:(UIView * _Nonnull)noiseTaggingView SWIFT_WARN_UNUSED_RESULT;
/// Called whenever the <code>mode</code> of <code>NoiseTagging</code> changes.
- (void)respondToNoiseTagModeChange;
/// Called whenever a trial ends because the maximum trial duration has passed and no control is being pressed.
- (void)respondToNoClick;
/// Called just before trials start running.
- (void)trialsWillStartRunning;
/// Called just after trials stopped running.
- (void)trialsStoppedRunning;
/// Called after each update for logging purposes. If the delegate returns a <em>context description</em>, this is logged.
- (NSString * _Nullable)contextDescription SWIFT_WARN_UNUSED_RESULT;
/// This is part of functionality that will become available later on.
- (id <NoiseTagControl> _Nullable)nextTarget SWIFT_WARN_UNUSED_RESULT;
/// This is part of functionality that will become available later on.
- (BOOL)thereWillBeANextTarget SWIFT_WARN_UNUSED_RESULT;
/// This is part of functionality that will become available later on.
- (void)trialEnded;
@end


/// This class makes it easy to implement UI similar to what <code>UINavigationController</code> provides, but controllable via brain. The content displayed in a <code>UINavigationController</code> is defined using <em>pages</em>, see <code>Page</code>.
/// Pages can be:
/// important:
/// Currently <code>NavigatorTreeOfPages</code> assumes that the device orientation does not change. Furthermore, Settings pages assume the orientation is landscape.
/// <ul>
///   <li>
///     List pages, which have sub pages where the user can navigate to;
///   </li>
///   <li>
///     Settings pages, which provide automatically generated UI to edit settings (see <code>Setting</code>), or
///   </li>
///   <li>
///     View pages, which simply provide a <code>UIView</code> to be displayed.
///   </li>
/// </ul>
SWIFT_CLASS("_TtC12NoiseTagging20NavigatorTreeOfPages")
@interface NavigatorTreeOfPages : NSObject <NoiseTagDelegate>
/// Pop the current page, making the previous page on the stack the current page.
/// The popped page moves to the right.
/// \param completion This closure is executed once the animation finishes.
///
- (void)popWithCompletion:(void (^ _Nullable)(void))completion;
/// See <code>NoiseTagDelegate</code>.
- (void)startNoiseTagControlOnNoiseTaggingView:(UIView * _Nonnull)noiseTaggingView;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum NoiseTagControlAppearance : NSInteger;

/// A button with either a title or an image.
SWIFT_CLASS("_TtC12NoiseTagging18NoiseTagButtonView")
@interface NoiseTagButtonView : UIView
/// Implementation of <code>NoiseTagControl</code>‘s <code>show(appearance:withDefaultColor</code> function. We simply set the passed <code>color</code> as our layer’s background color.
- (void)showWithAppearance:(enum NoiseTagControlAppearance)appearance withDefaultColor:(UIColor * _Nonnull)defaultColor;
/// Initialize a new <code>NoiseTagButtonView</code>.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Initialize using the passed <code>frame</code>.
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
/// Initialize from the passed <code>NSCoder</code>.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// We override <code>layoutSubviews</code> to keep our layout correct whenever our <code>bounds</code> change.
- (void)layoutSubviews;
@end


/// A noisetagging button consisting of two parts: a flickering part with an image, and an optionally non-flickering part with a title.
SWIFT_CLASS("_TtC12NoiseTagging25NoiseTagLabeledButtonView")
@interface NoiseTagLabeledButtonView : UIView
/// Initialize a new <code>NoiseTagLabeledButtonView</code> with the passed <code>frame</code>. The default label location <code>.Right</code> is used.
- (nonnull instancetype)initWithFrame:(CGRect)frame;
/// Initialize from the passed <code>NSCoder</code>.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// Implementation of <code>NoiseTagControl</code>’s <code>show(appearance:withDefaultColor</code> function.
/// The part of us where we display the image always flickers. The part of us where we display the title only flickers if the <code>labeledButtonsOnlyPartlyFlicker</code> setting is <code>false</code>.
- (void)showWithAppearance:(enum NoiseTagControlAppearance)appearance withDefaultColor:(UIColor * _Nonnull)defaultColor;
/// We override this in order to hide the line that divides our two parts  when flickering is on.
- (void)updateUIDependingOnNoiseTagging;
@end


/// A brain-controllable checkbox.
/// note:
/// You still need to set a noise tagging action on <code>NoiseTagCheckBoxView</code> and toggle its <code>isOn</code> property whenever it is pressed. <code>NoiseTagCheckBoxView</code> only takes care of reflecting the current state in its title and image.
SWIFT_CLASS("_TtC12NoiseTagging20NoiseTagCheckBoxView")
@interface NoiseTagCheckBoxView : NoiseTagLabeledButtonView
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/// Objects conforming to <code>NoiseTagControl</code> are <em>controls</em>. Being a control means being a brain-pressable button.
/// The most important tasks of these buttons are:
/// <ol>
///   <li>
///     to show noise tags, and
///   </li>
///   <li>
///     to perform actions when they are being pressed, be it by brain or finger.
///   </li>
/// </ol>
/// In the future non-button control types might become availalable as well.
/// <ul>
///   <li>
///     See Also: Check out the <em>Main Programming Guide</em> for details on how to make your own <code>NoiseTagControl</code>-conformant classes.
///   </li>
/// </ul>
SWIFT_PROTOCOL("_TtP12NoiseTagging15NoiseTagControl_")
@protocol NoiseTagControl <NSObject>
/// This function is called by <code>NoiseTagging</code> to show a noise tag on the control.
/// The control should update its appearance accordingly, e.g. by changing its background color. The default color for a bit can be obtained using <code>NoiseTagging.colorFor(bit:)</code>.
/// \param noiseTagBit The current bit of the control’s noise tag.
///
- (void)showWithAppearance:(enum NoiseTagControlAppearance)appearance withDefaultColor:(UIColor * _Nonnull)defaultColor;
/// This function is called by <code>NoiseTagging</code> to show <em>feedback</em> colors on the control, for example for <em>highlighting</em> – indicating that the user should look at the control during calibration –, or for providing visual feedback when there is a button press. By default <code>UIView</code> calls <code>show(appearance:withDefaultColor:)</code>, using the <code>.Other</code> appearance and passing this color.
/// \param color The color that should be used for providing the feedback.
///
- (void)setFeedbackColorWithColor:(UIColor * _Nullable)color;
/// This function allows controls to respond when the state of <code>NoiseTagging</code> changes in some way that might be relevant for their appearance. Currently this only is called when the flickering starts or stops. <code>UIView</code>’s default implementation is as follows:
/// \code
/// let defaultColor = self.noiseTagging.enabled ? self.defaultColorWhenEnabled : self.defaultColorWhenDisabled
/// self.show(appearance: self.noiseTagging.enabled ? NoiseTagControlAppearance.Enabled : NoiseTagControlAppearance.Disabled, withDefaultColor: defaultColor)
///
/// \endcode
- (void)updateUIDependingOnNoiseTagging;
/// In order to allow the user to press buttons using touch, the framework performs a simple kind of hit test. A tap is considered to be on a control if it is in the bounds of the layer returned by this function. By default <code>UIView</code> simply returns its <code>layer</code>.
- (CALayer * _Nullable)layerToHandleNoiseTagTaps SWIFT_WARN_UNUSED_RESULT;
/// The framework applies a number of animations to controls. For example it might make a control ‘wiggle’ to indicate that the user should look at, or it might animate a control’s size when it is pressed by touch. These animations are applied to the layer returned by this function. By default <code>UIView</code> simply returns its <code>layer</code>.
- (CALayer * _Nonnull)layerForFeedbackAnimations SWIFT_WARN_UNUSED_RESULT;
/// The framework may use Metal for drawing the parts of the UI that actually flicker. If Metal is used, for each control the contents of the layer returned by this function is what is drawn using Metal, in a view on top of everything else. By default <code>UIView</code> simply returns its <code>layer</code>.
- (CALayer * _Nonnull)layerFlickeringPart SWIFT_WARN_UNUSED_RESULT;
/// The hit test applied by <code>layerToHandleNoiseTagTaps</code> always fails if this function returns <code>true</code>. Also, brain presses are only possible on controls for which this returns <code>false</code>. This prevents that controls that are in the view hierarchy, invisible but enabled, be it by accident or on purpose, can still be pressed. By default <code>UIView</code> returns <code>false</code> only if its <code>isHidden</code> property is <code>false</code> and the same holds for all of its super views.
@property (nonatomic, readonly) BOOL isHiddenOrIsInHiddenView;
@optional
/// Allows controls to respond when the value of <code>self.noiseTagging.participatesInFlickering</code> changes.
- (void)participatesInFlickering_didChangeValue;
/// Allows controls to respond when the value of <code>self.noiseTagging.enabled</code> changes.
- (void)noiseTagControlIsEnabled_didChangeValue;
@end

/// Different possible appearances of Noise tag controls.
typedef SWIFT_ENUM(NSInteger, NoiseTagControlAppearance, open) {
/// Control shows a noise tag’s 0.
  NoiseTagControlAppearanceFlicker0 = 0,
/// Control shows a noise tag’s 1.
  NoiseTagControlAppearanceFlicker1 = 1,
/// Control is not flickering and its appearance indicates that it is enabled.
  NoiseTagControlAppearanceEnabled = 2,
/// Control is not flickering and its appearance indicates that it is disabled.
  NoiseTagControlAppearanceDisabled = 3,
/// Control is not flickering and its appearance is different from the other cases. For example this is used for temporarily changing the color of a control when it is pressed.
  NoiseTagControlAppearanceOther = 4,
};


/// Each <code>NoiseTagControl</code> has a <code>noiseTagging</code> property of type <code>NoiseTagControlProperties</code>. The purpose of this <code>noiseTagging</code> property is to store a number of things that are needed to make noise tagging work. It is also your main point of access to define how each control behaves as a brain-pressable button.
SWIFT_CLASS("_TtC12NoiseTagging25NoiseTagControlProperties")
@interface NoiseTagControlProperties : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This class provides a singleton <code>NoiseTagController</code>, which is responsible for coordinating everything that has to do with noise tagging. Access the singleton instance using the convenience variable <code>NoiseTagging</code>.
SWIFT_CLASS("_TtC12NoiseTagging18NoiseTagController")
@interface NoiseTagController : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




@interface NoiseTagController (SWIFT_EXTENSION(NoiseTagging))
/// In the future this will no longer be public.
+ (NSInteger)nFramesPerBit SWIFT_WARN_UNUSED_RESULT;
@end



/// Protocol for the delegate of a <code>NoiseTagKeyboardViewController</code>.
SWIFT_PROTOCOL("_TtP12NoiseTagging24NoiseTagKeyboardDelegate_")
@protocol NoiseTagKeyboardDelegate
@optional
/// <code>NoiseTagKeyboardViewController</code> uses button ids to perform the appropriate action whenever one of its buttons is pressed. This function provides the delegate the opportunity to respond to a button press. This can be used in combination with <code>NoiseTagKeyboardViewController</code>‘s <code>customizableButtonStates</code> property, which allows clients to add custom buttons to the keyboard’s bottomright area.
/// Return <code>true</code> if you handle the press.
- (BOOL)customActionOnPressOnKeyWithIdInKeyboard:(NSString * _Nonnull)idInKeyboard SWIFT_WARN_UNUSED_RESULT;
/// Called when the user presses the keyboard’s Ready button. Normally the delegate should dismiss the <code>NoiseTagKeyboardViewController</code>.
- (void)readyButtonPressedInKeyboard;
@end

@class NSBundle;

/// A view controller which presents a brain-controllable keyboard.
SWIFT_CLASS("_TtC12NoiseTagging30NoiseTagKeyboardViewController")
@interface NoiseTagKeyboardViewController : UIViewController <NoiseTagDelegate>
/// Initialize a new <code>NoiseTagKeyboardViewController</code>.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder SWIFT_UNAVAILABLE;
/// See <code>NoiseTagDelegate</code>.
/// important:
/// You should not call this function directly.
- (void)startNoiseTagControlOnNoiseTaggingView:(UIView * _Nonnull)noiseTaggingView;
- (void)respondToNoiseTagModeChange;
- (NSArray<NSString *> * _Nullable)idsOfControlsToIncludeAsTargetInVerifyModeWithNoiseTaggingView:(UIView * _Nonnull)noiseTaggingView SWIFT_WARN_UNUSED_RESULT;
/// See <code>UIViewController</code>.
- (void)viewDidLoad;
/// See <code>UIViewController</code>.
- (void)viewDidAppear:(BOOL)animated;
/// See <code>UIViewController</code>.
- (void)viewDidLayoutSubviews;
/// See <code>UIViewController</code>.
@property (nonatomic, readonly) BOOL prefersStatusBarHidden;
/// We prefer the home indicator to be hidden.
@property (nonatomic, readonly) BOOL prefersHomeIndicatorAutoHidden;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


@class UIPopoverPresentationController;

/// A <code>NoiseTagLabeledButtonView</code> which when pressed lets the user pick one out of a list of possible items in a popover.
SWIFT_CLASS("_TtC12NoiseTagging23NoiseTagPopupButtonView")
@interface NoiseTagPopupButtonView : NoiseTagLabeledButtonView <NoiseTagDelegate, UIPopoverPresentationControllerDelegate>
/// Initialize a new <code>NoiseTagPopupButtonView</code> from the passed <code>coder</code>.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// When a <code>NoiseTagPopupButtonView</code> is pressed, it presents a popover and pushes a new unit on the noise tagging stack. It becomes this unit’s delegate. In this <code>NoiseTagDelegate</code> function we prepare the popover’s contents for noise tagging control.
/// important:
/// you should not call this function. It is only public in order to implement <code>NoiseTagDelegate</code>.
- (void)startNoiseTagControlOnNoiseTaggingView:(UIView * _Nonnull)noiseTaggingView;
/// See <code>UIPopoverPresentationControllerDelegate</code>.
- (BOOL)popoverPresentationControllerShouldDismissPopover:(UIPopoverPresentationController * _Nonnull)_ SWIFT_WARN_UNUSED_RESULT;
/// See <code>UIPopoverPresentationControllerDelegate</code>.
- (void)popoverPresentationControllerDidDismissPopover:(UIPopoverPresentationController * _Nonnull)popoverPresentationController;
@end


/// Used for modeling the items a user can choose from in a <code>NoiseTagPopupButtonView</code>.
SWIFT_CLASS("_TtC12NoiseTagging17NoiseTagPopupItem")
@interface NoiseTagPopupItem : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A brain-controllable radio button.
/// note:
/// You still need to set a noise tagging action and toggle the <code>isOn</code> property. <code>NoiseTagRadioButton</code> only takes care of reflecting the current state in its image.
SWIFT_CLASS("_TtC12NoiseTagging19NoiseTagRadioButton")
@interface NoiseTagRadioButton : NoiseTagLabeledButtonView
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/// Each <code>Setting</code> can have one or more observers, which are informed whenever the setting changes value.
SWIFT_PROTOCOL("_TtP12NoiseTagging15SettingObserver_")
@protocol SettingObserver
/// Whenever a <code>Setting</code>’s value changes, it calls this on each of its <code>observers</code>.
- (void)valueChangedForSetting:(id <Setting> _Nonnull)setting;
@end


/// A collection of <code>Setting</code>s.
SWIFT_CLASS("_TtC12NoiseTagging13SetOfSettings")
@interface SetOfSettings : NSObject <NSCoding, NSCopying, SettingObserver>
/// Initialize a new <code>SetOfSettings</code>.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// See <code>NSCopying</code>.
/// important:
/// Subclasses should override this if they want the result to be castable to their own class.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// See <code>NSCoding</code>.
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// See <code>NSCoding</code>.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// See <code>SettingDelegate</code>.
- (void)valueChangedForSetting:(id <Setting> _Nonnull)setting;
@end


/// Used for modeling NoiseTagController’s settings. Note that this class does <em>not</em> control which specific settings are added to it. To get an overview of the settings that NoiseTagController uses, see <code>NoiseTagSettingTitles</code>.
SWIFT_CLASS("_TtC12NoiseTagging21NoiseTagSetOfSettings")
@interface NoiseTagSetOfSettings : SetOfSettings
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// This initializer is required, but does not do anything.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// See <code>NSCopying</code>.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@end


/// A <code>NoiseTagButtonView</code>, but with a shape defined by a <code>CGPath</code> instead of a regular rectangle.
SWIFT_CLASS("_TtC12NoiseTagging23NoiseTagShapeButtonView")
@interface NoiseTagShapeButtonView : NoiseTagButtonView
/// Initialize using the passed <code>frame</code>.
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
/// Initialize from the passed <code>NSCoder</code>.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// See <code>NoiseTagControl</code>.
- (CALayer * _Nullable)layerToHandleNoiseTagTaps SWIFT_WARN_UNUSED_RESULT;
/// See <code>NoiseTagControl</code>.
- (void)showWithAppearance:(enum NoiseTagControlAppearance)appearance withDefaultColor:(UIColor * _Nonnull)defaultColor;
/// See <code>NoiseTagControl</code>.
- (void)noiseTagControlIsEnabled_didChangeValue;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Used by the NoiseTagging framework to show brain-controllable alerts. Each <code>NoiseTaggingAlertAction</code> models a choice that the user can take to dismiss the alert.
SWIFT_CLASS("_TtC12NoiseTagging23NoiseTaggingAlertAction")
@interface NoiseTaggingAlertAction : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A <code>Page</code> defines content that can be displayed in a <code>NavigatorTreeOfPages</code>.
/// Pages are always used in conjunction with <code>NavigatorTreeOfPages</code>, which makes it easy to implement UI similar to what <code>UINavigationController</code> provides, but controllable via brain. A <code>Page</code> always has a <code>title</code>. Depending on the other properties you set, you use it in one of three possible ways:
/// <ol>
///   <li>
///     <em>View Pages</em>: If you set a view, when the page becomes <code>NavigatorTreeOfPages</code>’s current page, <code>NavigatorTreeOfPages</code> simply shows that view beneath its navigation bar.
///   </li>
///   <li>
///     <em>Settings Pages</em>: If you set an array of settings, the page will create a view, set it on itself, and populate it with UI for editing those settings. This means a Settings Page actually is a specific kind of View Page.
///   </li>
///   <li>
///     <em>List Pages</em>: If you set <code>subPages</code>, when the page becomes <code>NavigatorTreeOfPages</code>’s current page, <code>NavigatorTreeOfPages</code> shows one row per subPage and lets the user navigate to the subPages.
///   </li>
/// </ol>
/// Note that in the first two cases, it is still possible to push pages on <code>NavigatorTreeOfPages</code>, but in the third case pushing pages is handled by <code>NavigatorTreeOfPages</code>.
/// note:
/// Settings pages assume the orientation is landscape.
SWIFT_CLASS("_TtC12NoiseTagging4Page")
@interface Page : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A <code>PickableColor</code> models a color that can be selected as a <code>ColorSetting</code>’s current value.
SWIFT_CLASS("_TtC12NoiseTagging13PickableColor")
@interface PickableColor : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A recording has a start and at some point an end and groups togther a number of log files.
SWIFT_CLASS("_TtC12NoiseTagging9Recording")
@interface Recording : NSObject
/// See the <code>NSCoding</code> protocol.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// See the <code>NSCoding</code> protocol.
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// An in-memory database holding <code>SyncableObject</code>s, which can be synced automatically to disk and/or iCloud.
SWIFT_CLASS("_TtC12NoiseTagging16SyncableDatabase")
@interface SyncableDatabase : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Provides a singleton for making and accessing recordings, which include log files.
SWIFT_CLASS("_TtC12NoiseTagging18Recordingsdatabase")
@interface Recordingsdatabase : SyncableDatabase
@end


/// The result of a ‘validity check’. See <code>Setting.validityCheck</code>.
SWIFT_CLASS("_TtC12NoiseTagging19ResultValidityCheck")
@interface ResultValidityCheck : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Provided a singleton for generating text-to-speech. Use <code>Saying</code> for convenient access to this singleton.
SWIFT_CLASS("_TtC12NoiseTagging5Sayer")
@interface Sayer : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// Used to define settings for a <code>NoiseTagKeyboardViewController</code>.
/// The setting titles of a <code>SetOfSettingsNoiseTagKeyboard</code> are defined by <code>NoiseTagKeyboardSettingTitles</code>.
SWIFT_CLASS("_TtC12NoiseTagging29SetOfSettingsNoiseTagKeyboard")
@interface SetOfSettingsNoiseTagKeyboard : SetOfSettings
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// See <code>NSCopying</code>.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@end




@class UITableView;
@class UITableViewCell;

/// A <code>SettingsTableViewController</code> can be used to let the user edit settings.
/// important:
/// Currently you should only use <code>SettingsTableViewController.newViewControllerForEditing(settings).</code>
SWIFT_CLASS("_TtC12NoiseTagging27SettingsTableViewController")
@interface SettingsTableViewController : UITableViewController <SettingObserver>
/// We override <code>UITableViewController</code>’s <code>prefersStatusBarHidden</code> to hide the status bar.
@property (nonatomic, readonly) BOOL prefersStatusBarHidden;
/// Superclass override.
- (void)viewDidLoad;
/// Superclass override.
- (void)viewWillAppear:(BOOL)animated;
/// See <code>UITableViewController</code>.
- (NSInteger)numberOfSectionsInTableView:(UITableView * _Nonnull)tableView SWIFT_WARN_UNUSED_RESULT;
/// See <code>UITableViewController</code>.
- (NSInteger)tableView:(UITableView * _Nonnull)tableView numberOfRowsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// See <code>UITableViewController</code>.
- (UITableViewCell * _Nonnull)tableView:(UITableView * _Nonnull)tableView cellForRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// See <code>UITableViewController</code>.
- (CGFloat)tableView:(UITableView * _Nonnull)tableView heightForRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// See <code>UITableViewController</code>.
- (NSString * _Nullable)tableView:(UITableView * _Nonnull)tableView titleForHeaderInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// See <code>UITableViewController</code>.
- (CGFloat)tableView:(UITableView * _Nonnull)tableView heightForHeaderInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// See <code>SettingDelegate</code>.
- (void)valueChangedForSetting:(id <Setting> _Nonnull)setting;
- (nonnull instancetype)initWithStyle:(UITableViewStyle)style OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class AVAudioPlayer;

/// This class lets you play short sounds (max 30s).
SWIFT_CLASS("_TtC12NoiseTagging12SoundsHelper")
@interface SoundsHelper : NSObject <AVAudioPlayerDelegate>
/// See <code>AVAudioPlayerDelegate</code>.
- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer * _Nonnull)player successfully:(BOOL)flag;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// A <code>Setting</code> with a <code>String</code> value.
SWIFT_CLASS("_TtC12NoiseTagging11TextSetting")
@interface TextSetting : Setting_abstract <NSCoding, Setting>
/// Copy the <code>StringSetting</code>.
/// seealso:
/// <code>NSCopying</code>.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// Encode the <code>StringSetting</code>.
/// seealso:
/// <code>NSCoding</code>.
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// Initialize a new <code>StringSetting</code> by decoding from <code>aDecoder</code>.
/// seealso:
/// <code>NSCoding</code>.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// A user-friendly description of the <code>StringSetting</code>.
/// seealso:
/// <code>CustomStringConvertible</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// A description of the setting’s value, assuming a value is defined. Used for logging purposes.
@property (nonatomic, readonly, copy) NSString * _Nonnull descriptionValueIfDefined;
/// The setting’s value described using JSON. Used for logging purposes.
@property (nonatomic, readonly) id _Nonnull valueAsJson;
/// Sets the receiver’s setting value to the setting value of <code>newSetting</code>.
- (void)updateValueToMatchWithNewSetting:(id <Setting> _Nonnull)newSetting;
/// Settings may have a default value, which can easily be restored by the user using the standard UI for editing settings provided by the NoiseTagging framework.
@property (nonatomic, readonly) BOOL valueEqualsDefaultValue;
/// Set the setting value to the default value.
/// seealso:
/// <code>hasDefaultValue</code>
- (void)resetToDefault;
/// The name of the nib used for generating UI for editing the setting.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellNibName;
/// The NoiseTagging framework provides standard UI for editing settings. This UI consists of a table view, where each cell is used for one setting. The <code>cellReuseIdentifier</code> makes it possible to reuse these cells per setting type.
@property (nonatomic, readonly, copy) NSString * _Nonnull cellReuseIdentifier;
@end










@interface UIView (SWIFT_EXTENSION(NoiseTagging)) <NoiseTagControl>
@property (nonatomic, readonly) BOOL isHiddenOrIsInHiddenView;
- (void)showWithAppearance:(enum NoiseTagControlAppearance)appearance withDefaultColor:(UIColor * _Nonnull)defaultColor;
- (void)setFeedbackColorWithColor:(UIColor * _Nullable)color;
- (CALayer * _Nullable)layerToHandleNoiseTagTaps SWIFT_WARN_UNUSED_RESULT;
- (CALayer * _Nonnull)layerFlickeringPart SWIFT_WARN_UNUSED_RESULT;
- (CALayer * _Nonnull)layerForFeedbackAnimations SWIFT_WARN_UNUSED_RESULT;
- (void)noiseTagControlIsEnabled_didChangeValue;
- (void)updateUIDependingOnNoiseTagging;
@end






/// A <code>VoiceDefinition</code> defines a voice that can be used for speech generation. This is used by <code>Saying</code>.
SWIFT_CLASS("_TtC12NoiseTagging15VoiceDefinition")
@interface VoiceDefinition : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
